using System;
using System.Collections.Generic;
using System.IO;

namespace ScribdMpubToEpubConverter.Scribd
{
	struct HtmlImage
	{
		public string AbsoluteFilePath { get; set; }
		public byte[] Content { get; set; }
		public string ID { get; set; }
	}

	struct Chapter
	{
		// Content of this chapter
		public ChapterContent Content { get; set; }

		// Title of this chapter
		public string Title { get; set; }

		// The file path is relative to the current table of content file directory
		public string FilePath { get; set; }

		// Type of this chapter (i.e. frontmatter, content)
		public string Type { get; set; }

		// HTML content of this chapter, generated by the parser
		public string HTML { get; set; }

		// Name of this HTML file, generated by the parser
		public string OutputFileName { get; set; }
	}

	// TODO: Compare number of folders found in chapters/ to
	// the number of chapters found in the Table of Content?
	// TODO: Check the name of titles found in each Chapter and those
	// reported by Table of Content?
	/**
	 * This class loads information in the following order:
	 * 1) Styles (AcquireStyles)
	 * 2) Metadata (AcquireMetadata)
	 * 3) Tags (AcquireTags)
	 * 3) Book title (AcquireBookTitle)
	 * 4) Table of Content (AcquireContent)
	 * 5) Chapters (AcquireContent)
	 */
	class Book
	{
		// Main directory of this book
		// Where the table of contents, metadata and other JSON files are located
		public string Directory { get; set; }

		// Title of this book, extracted from book_metadata.json
		public string Title { get; set; }

		// ID of this book, extracted from folder name
		public string ID { get; set; }

		// Cover page is listed as a separate chapter
		// NOTE: Only HTML and Title fields are populated for the cover page
		public Chapter CoverPage { get; set; }

		// Holds information on all of the chapters
		public AdditionalChapterInformation[] TableOfContents { get; set; }

		// List of all chapters
		public Chapter[] Chapters { get; set; }

		// Holds a list of predefined CSS styles in the following way:
		// Style name, Style content
		public Dictionary<string, string> Styles { get; set; }

		// List of all metadata information
		public Dictionary<string, MetadataContent> Metadata { get; set; }

		// Holds a list of predefined page tags that we're going
		// to use to relink link attributes
		public Dictionary<string, TagContent> Tags = new Dictionary<string, TagContent>();

		// List of all images, in the following way:
		// Image name (without extension), HtmlImage
		public Dictionary<string, HtmlImage> Images = new Dictionary<string, HtmlImage>();

		public Book(string book_directory)
		{
			Directory = book_directory;
			ID = Path.GetFileName(book_directory);

			// styles.json should be present in a book
			var styles_path = book_directory + Path.DirectorySeparatorChar + "styles.json";
			if (File.Exists(styles_path))
				AcquireStyles(styles_path);

			// metadata.json should be present in a book
			var metadata_path = book_directory + Path.DirectorySeparatorChar + "metadata.json";
			if (File.Exists(metadata_path))
				AcquireMetadata(metadata_path);

			// tags.json should be present in a book
			var tags_path = book_directory + Path.DirectorySeparatorChar + "tags.json";
			if (File.Exists(tags_path))
				AcquireTags(tags_path);

			// book_metadata.json and toc.json are always present
			// (unless something went horribly wrong, and then we intentionally let havoc wreak)
			AcquireBookTitle(book_directory + Path.DirectorySeparatorChar + "book_metadata.json");
			AcquireTableOfContents(book_directory + Path.DirectorySeparatorChar + "toc.json");
			AcquireContent();
		}

		private void AcquireBookTitle(string book_metadata_path)
		{
			Helper.Debug("Reading book_metadata.json");

			var book_metadata_content = File.ReadAllText(book_metadata_path);
			if (book_metadata_content.Length < 4)
				throw new Exception("File too short! Path: " + book_metadata_path);

			JObject jObject = JObject.Parse(book_metadata_content);
			var title = jObject["title"];
			if (0 == title.Children().Count())
            		{
				Title = (string)title;
            		}
            		else
            		{
				Title = (string)title["#text"];
			}
			Helper.Debug("Book title: " + Title);
		}

		private void AcquireTableOfContents(string table_of_content_path)
		{
			Helper.Debug("Reading toc.json");

			var table_of_contents_content = File.ReadAllText(table_of_content_path);
			if (table_of_contents_content.Length < 4)
				throw new Exception("File too short! Path: " + table_of_content_path);

			TableOfContents = TableOfContentsDeserializer.Deserialize(table_of_contents_content);
		}

		private void AcquireContent()
		{
			// The number of chapters is equal to the number of entries in the table of content
			Chapters = new Chapter[TableOfContents.Length];

			// Add chapters
			for (int i = 0; i < TableOfContents.Length; ++i)
			{
				Chapters[i].Type = TableOfContents[i].Type;
				Chapters[i].Title = TableOfContents[i].Title;
				Chapters[i].FilePath = TableOfContents[i].FilePath;
				Chapters[i].OutputFileName = "chapter" + i.ToString("D4") + ".html";

				var chapter_path = Directory +
					Path.DirectorySeparatorChar +
					Chapters[i].FilePath +
					Path.DirectorySeparatorChar +
					"contents.json";

				Helper.Debug("Reading chapter contents: " + Chapters[i].FilePath);

				var chapter_content = File.ReadAllText(chapter_path);
				if (chapter_content.Length < 4)
					throw new Exception("File too short! Path: " + Chapters[i].FilePath);

				using var reader = new StreamReader(File.OpenRead(chapter_path));
				Chapters[i].Content = ChapterContentDeserializer.Deserialize(reader);
			}

			Helper.Debug("Chapter entries: " + Chapters.Length);
		}

		private void AcquireMetadata(string metadata_path)
		{
			Helper.Debug("Reading metadata.json");

			var metadata_content = File.ReadAllText(metadata_path);
			if (metadata_content.Length < 4)
				throw new Exception("File too short! Path: " + metadata_path);

			Metadata = MetadataDeserializer.Deserialize(metadata_content);
			Helper.Debug("Metadata entries: " + Metadata.Count);
		}

		private void AcquireStyles(string styles_path)
		{
			Helper.Debug("Reading styles.json");

			var styles_content = File.ReadAllText(styles_path);
			if (styles_content.Length < 4)
				throw new Exception("File too short! Path: " + styles_path);

			Styles = StylesDeserializer.Deserialize(styles_content);
			Helper.Debug("Styles entries: " + Styles.Count);
		}

		private void AcquireTags(string tags_path)
		{
			Helper.Debug("Reading tags.json");

			var tags_content = File.ReadAllText(tags_path);
			if (tags_content.Length < 4)
				throw new Exception("File too short! Path: " + tags_path);

			Tags = TagsDeserializer.Deserialize(tags_content).Tags;

			Helper.Debug("Tags entries: " + Tags.Count);
		}
	}
}
